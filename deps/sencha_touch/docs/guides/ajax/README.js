Ext.data.JsonP.ajax({"guide":"<h1>AJAX with Sencha Touch 2</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/ajax-section-1'>Simple Requests with <a href=\"#!/api/Ext.Ajax\" rel=\"Ext.Ajax\" class=\"docClass\">Ext.Ajax</a></a></li>\n<li><a href='#!/guide/ajax-section-2'>Cross-Domain Requests</a></li>\n<li><a href='#!/guide/ajax-section-3'>Form Uploads</a></li>\n</ol>\n</div>\n\n<p>Sencha Touch 2 provides a variety of convenient ways to get data into and out of your application. All of the data-bound Components like Lists, Nested Lists and DataViews use Stores, which are easily configured to fetch and save data to a large variety of sources. We'll look at managing data with stores later on but first let's start with how to issue simple AJAX requests.</p>\n\n<h2 id='ajax-section-1'>Simple Requests with <a href=\"#!/api/Ext.Ajax\" rel=\"Ext.Ajax\" class=\"docClass\">Ext.Ajax</a></h2>\n\n<p>AJAX requests are usually made to urls on the same domain as your application. For example, if your application is found at http://myapp.com, you can send AJAX requests to urls like http://myapp.com/login.php and http://myapp.com/products/1.json but not to other domains like http://google.com. This is because of browser security restrictions, but Sencha Touch does provide some alternatives to get around this, which we'll look at shortly (Cross-Domain Requests and JSON-P).</p>\n\n<p>For now, here's how we can make an AJAX request to load data form a url on our domain:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>Assuming your app is on http://myapp.com, this is going to send a GET request to http://myapp.com/myUrl. AJAX calls are asynchronous so once the response comes back, our callback function is called with the response. All we're doing above is logging the contents of the response to the console when the request has finished. Pretty simple so far, let's see what else we can do.</p>\n\n<h3>AJAX Options</h3>\n\n<p><a href=\"#!/api/Ext.Ajax\" rel=\"Ext.Ajax\" class=\"docClass\">Ext.Ajax</a> takes a wide variety of options, including setting the method (GET, POST, PUT or DELETE), sending headers and setting params to be sent in the url. First let's see how to set the method so we send a POST request instead of GET:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    method: 'POST',\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>Sending parameters is also easy:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    params: {\n        username: 'Ed',\n        password: 'not a good place to put a password'\n    },\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>When we set params like this, the request is automatically sent as a POST with the params object sent as form data. The request above is just like submitting a form with username and password fields.</p>\n\n<p>If we wanted to send this as a GET request instead we can specify the method again, in which case our params are automatically escaped and appended to the url for us:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    method: 'GET',\n\n    params: {\n        username: 'Ed',\n        password: 'bad place for a password'\n    },\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>Which sends a request to:</p>\n\n<pre><code>http://mywebsite.com/myUrl?_dc=1329443875411&amp;username=Ed&amp;password=bad%20place%20for%20a%20password\n</code></pre>\n\n<p>You may have noticed that our last request created a url that contained \"_dc=1329443875411\". When you make a GET request like this, many web servers will cache the response and send you back the same thing every time you make the request. This speeds the web up, but is not always what you want. In fact in applications it's rarely what you want, so we \"bust\" the cache for you by adding a timestamp to every request. This tells the web server to treat it is a fresh, uncached request.</p>\n\n<p>If you want to turn this behavior off, we can just set disableCaching to false:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    method: 'GET',\n    disableCaching: false,\n\n    params: {\n        username: 'Ed',\n        password: 'bad place for a password'\n    },\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>Now our request no longer contains the cache busting string, and looks more like this:</p>\n\n<pre><code>http://mywebsite.com/myUrl?username=Ed&amp;password=bad%20place%20for%20a%20password\n</code></pre>\n\n<h3>Sending Headers</h3>\n\n<p>The final option we'll look at when it comes to customizing the request itself is the headers option. This enables you to send any custom headers you want to your server, which is often useful when the web server returns different content based on those headers. For example, if your web server returns JSON, XML or CSV based on which header it is passed, we can ask it for JSON like this:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>If you create a request like this and inspect it in Firebug/web inspector you'll see that the Content-Type header has been set to application/json. Your web server can pick up on this and send you the right response. You can pass any number of headers you like into the headers option.</p>\n\n<h3>Callback Options</h3>\n\n<p>Not every AJAX request succeeds. Sometimes the server is down, or your internet connection drops, or something else bad happens. <a href=\"#!/api/Ext.Ajax\" rel=\"Ext.Ajax\" class=\"docClass\">Ext.Ajax</a> allows you to specify separate callbacks for each of these cases:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    success: function(response) {\n        console.log(\"Spiffing, everything worked\");\n    },\n\n    failure: function(response) {\n        console.log(\"Curses, something terrible happened\");\n    }\n});\n</code></pre>\n\n<p>These do exactly what you'd expect them to do, and hopefully most of the time it is your success callback that gets called. It's pretty common to provide a success callback that updates the UI or does whatever else is needed by the application flow, and a failure handler that either retries the request or alerts the user that something went wrong.</p>\n\n<p>You can provide <em>success</em>/<em>failure</em> and <em>callback</em> at the same time, so for this request if everything was ok our <em>success</em> function is called first, followed by the main <em>callback</em> function, otherwise it'll be <em>failure</em> followed by <em>callback</em>:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    success: function(response) {\n        console.log(\"Spiffing, everything worked\");\n    },\n\n    failure: function(response) {\n        console.log(\"Curses, something terrible happened\");\n    },\n\n    callback: function(response) {\n        console.log(\"It is what it is\");\n    }\n});\n</code></pre>\n\n<h3>Timeouts and Aborting Requests</h3>\n\n<p>Another way requests can fail is if the server took too long to respond and the request timed out. In this case your <em>failure</em> function will be called, and the request object it is passed will have timedout true:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    failure: function(response) {\n        alert.log(response.timedout); //alerts true\n    }\n});\n</code></pre>\n\n<p>By default the timeout threshold is 30 seconds, but you can specify it per request by setting the timeout in millisecond. In this case our request will give up after 5 seconds:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    timeout: 5000,\n\n    failure: function(response) {\n        alert.log(response.timedout); //alerts true\n    }\n});\n</code></pre>\n\n<p>It's also possible to abort requests that are currently outstanding. To do this you need to save a reference to the request object that <a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a> gives you:</p>\n\n<pre><code>var myRequest = <a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    failure: function(response) {\n        alert.log(response.aborted); //alerts true\n    }\n});\n\n<a href=\"#!/api/Ext.Ajax-method-abort\" rel=\"Ext.Ajax-method-abort\" class=\"docClass\">Ext.Ajax.abort</a>(myRequest);\n</code></pre>\n\n<p>This time our failure callback is called and its response.aborted property is set. We can use all of the error handling above in our apps:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    failure: function(response) {\n        if (response.timedout) {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Timeout', \"The server timed out :(\");\n        } else if (response.aborted) {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Aborted', \"Looks like you aborted the request\");\n        } else {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Bad', \"Something went wrong with your request\");\n        }\n    }\n});\n</code></pre>\n\n<h2 id='ajax-section-2'>Cross-Domain Requests</h2>\n\n<p>A relatively new capability of modern browsers is called <a href=\"http://www.w3.org/TR/cors/\">CORS</a>, which stands for Cross-Origin Resource Sharing. This allows you to send requests to other domains without the usual security restrictions enforced by the browser. Sencha Touch 2 has support for CORS, though you'll probably need to do a little setup on your web server to enable it. If you're not familiar with what you need to do on your web server to enable CORS, a quick google search should give you plenty of answers.</p>\n\n<p>Assuming your server is set up though, sending a CORS request is easy:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'http://www.somedomain.com/some/awesome/url.php',\n    withCredentials: true,\n    useDefaultXhrHeader: false\n});\n</code></pre>\n\n<h2 id='ajax-section-3'>Form Uploads</h2>\n\n<p>The final thing we'll cover is uploading forms. This is also really easy:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    form: 'myFormId',\n\n    callback: function(response, successful) {\n        if (successful) {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Success', 'We got your form submission');\n        } else {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Fail', 'Hmm, that did not work');\n        }\n    }\n});\n</code></pre>\n\n<p>This finds a &lt;form&gt; tag on the page with id=\"myFormId\", grabs its data and puts it into the request params object just like at the start of this guide. Then it submits it to the url you specified and calls your callbacks like normal.</p>\n","title":"Using AJAX"});