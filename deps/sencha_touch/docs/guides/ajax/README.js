Ext.data.JsonP.ajax({"title":"Using AJAX","guide":"<h1>AJAX with Sencha Touch 2</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/ajax-section-1'>Simple Requests with <a href=\"#!/api/Ext.Ajax\" rel=\"Ext.Ajax\" class=\"docClass\">Ext.Ajax</a></a></li>\n<li><a href='#!/guide/ajax-section-2'>Cross-Domain Requests</a></li>\n<li><a href='#!/guide/ajax-section-3'>Form Uploads</a></li>\n</ol>\n</div>\n\n<p>Sencha Touch 2 provides a variety of convenient ways to get data into and out of your application. All of the data-bound\nComponents like Lists, Nested Lists and DataViews use Stores, which are easily configured to fetch and save data to a\nlarge variety of sources. We'll look at managing data with stores later on but first let's start with how to issue\nsimple AJAX requests.</p>\n\n<h2 id='ajax-section-1'>Simple Requests with <a href=\"#!/api/Ext.Ajax\" rel=\"Ext.Ajax\" class=\"docClass\">Ext.Ajax</a></h2>\n\n<p>AJAX requests are usually made to urls on the same domain as your application. For example, if your application is found\nat http://myapp.com, you can send AJAX requests to urls like http://myapp.com/login.php and\nhttp://myapp.com/products/1.json but not to other domains like http://google.com. This is because of browser security\nrestrictions, but Sencha Touch does provide some alternatives to get around this, which we'll look at shortly\n(Cross-Domain Requests and JSON-P).</p>\n\n<p>For now, here's how we can make an AJAX request to load data form a url on our domain:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>Assuming your app is on http://myapp.com, this is going to send a GET request to http://myapp.com/myUrl. AJAX calls are\nasynchronous so once the response comes back, our callback function is called with the response. All we're doing above\nis logging the contents of the response to the console when the request has finished. Pretty simple so far, let's see\nwhat else we can do.</p>\n\n<h3>AJAX Options</h3>\n\n<p><a href=\"#!/api/Ext.Ajax\" rel=\"Ext.Ajax\" class=\"docClass\">Ext.Ajax</a> takes a wide variety of options, including setting the method (GET, POST, PUT or DELETE), sending headers and\nsetting params to be sent in the url. First let's see how to set the method so we send a POST request instead of GET:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    method: 'POST',\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>Sending parameters is also easy:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    params: {\n        username: 'Ed',\n        password: 'not a good place to put a password'\n    },\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>When we set params like this, the request is automatically sent as a POST with the params object sent as form data. The\nrequest above is just like submitting a form with username and password fields.</p>\n\n<p>If we wanted to send this as a GET request instead we can specify the method again, in which case our params are\nautomatically escaped and appended to the url for us:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    method: 'GET',\n\n    params: {\n        username: 'Ed',\n        password: 'bad place for a password'\n    },\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>Which sends a request to:</p>\n\n<pre><code>http://mywebsite.com/myUrl?_dc=1329443875411&amp;username=Ed&amp;password=bad%20place%20for%20a%20password\n</code></pre>\n\n<p>You may have noticed that our last request created a url that contained \"_dc=1329443875411\". When you make a GET request\nlike this, many web servers will cache the response and send you back the same thing every time you make the request.\nThis speeds the web up, but is not always what you want. In fact in applications it's rarely what you want, so we \"bust\"\nthe cache for you by adding a timestamp to every request. This tells the web server to treat it is a fresh, uncached\nrequest.</p>\n\n<p>If you want to turn this behavior off, we can just set disableCaching to false:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    method: 'GET',\n    disableCaching: false,\n\n    params: {\n        username: 'Ed',\n        password: 'bad place for a password'\n    },\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>Now our request no longer contains the cache busting string, and looks more like this:</p>\n\n<pre><code>http://mywebsite.com/myUrl?username=Ed&amp;password=bad%20place%20for%20a%20password\n</code></pre>\n\n<h3>Sending Headers</h3>\n\n<p>The final option we'll look at when it comes to customizing the request itself is the headers option. This enables you\nto send any custom headers you want to your server, which is often useful when the web server returns different content\nbased on those headers. For example, if your web server returns JSON, XML or CSV based on which header it is passed, we\ncan ask it for JSON like this:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n\n    callback: function(response) {\n        console.log(response.responseText);\n    }\n});\n</code></pre>\n\n<p>If you create a request like this and inspect it in Firebug/web inspector you'll see that the Content-Type header has\nbeen set to application/json. Your web server can pick up on this and send you the right response. You can pass any\nnumber of headers you like into the headers option.</p>\n\n<h3>Callback Options</h3>\n\n<p>Not every AJAX request succeeds. Sometimes the server is down, or your internet connection drops, or something else bad\nhappens. <a href=\"#!/api/Ext.Ajax\" rel=\"Ext.Ajax\" class=\"docClass\">Ext.Ajax</a> allows you to specify separate callbacks for each of these cases:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    success: function(response) {\n        console.log(\"Spiffing, everything worked\");\n    },\n\n    failure: function(response) {\n        console.log(\"Curses, something terrible happened\");\n    }\n});\n</code></pre>\n\n<p>These do exactly what you'd expect them to do, and hopefully most of the time it is your success callback that gets\ncalled. It's pretty common to provide a success callback that updates the UI or does whatever else is needed by the\napplication flow, and a failure handler that either retries the request or alerts the user that something went wrong.</p>\n\n<p>You can provide <em>success</em>/<em>failure</em> and <em>callback</em> at the same time, so for this request if everything was ok our\n<em>success</em> function is called first, followed by the main <em>callback</em> function, otherwise it'll be <em>failure</em> followed\nby <em>callback</em>:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    success: function(response) {\n        console.log(\"Spiffing, everything worked\");\n    },\n\n    failure: function(response) {\n        console.log(\"Curses, something terrible happened\");\n    },\n\n    callback: function(response) {\n        console.log(\"It is what it is\");\n    }\n});\n</code></pre>\n\n<h3>Timeouts and Aborting Requests</h3>\n\n<p>Another way requests can fail is if the server took too long to respond and the request timed out. In this case your\n<em>failure</em> function will be called, and the request object it is passed will have timedout true:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    failure: function(response) {\n        console.log(response.timedout); // logs true\n    }\n});\n</code></pre>\n\n<p>By default the timeout threshold is 30 seconds, but you can specify it per request by setting the timeout in\nmillisecond. In this case our request will give up after 5 seconds:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    timeout: 5000,\n\n    failure: function(response) {\n        console.log(response.timedout); // logs true\n    }\n});\n</code></pre>\n\n<p>It's also possible to abort requests that are currently outstanding. To do this you need to save a reference to the\nrequest object that <a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a> gives you:</p>\n\n<pre><code>var myRequest = <a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    failure: function(response) {\n        console.log(response.aborted); // logs true\n    }\n});\n\n<a href=\"#!/api/Ext.Ajax-method-abort\" rel=\"Ext.Ajax-method-abort\" class=\"docClass\">Ext.Ajax.abort</a>(myRequest);\n</code></pre>\n\n<p>This time our failure callback is called and its response.aborted property is set. We can use all of the error handling\nabove in our apps:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n\n    failure: function(response) {\n        if (response.timedout) {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Timeout', \"The server timed out :(\");\n        } else if (response.aborted) {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Aborted', \"Looks like you aborted the request\");\n        } else {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Bad', \"Something went wrong with your request\");\n        }\n    }\n});\n</code></pre>\n\n<h2 id='ajax-section-2'>Cross-Domain Requests</h2>\n\n<p>A relatively new capability of modern browsers is called <a href=\"http://www.w3.org/TR/cors/\">CORS</a>, which stands\nfor Cross-Origin Resource Sharing. This allows you to send requests to other domains without the usual security\nrestrictions enforced by the browser. Sencha Touch 2 has support for CORS, though you'll probably need to do a little\nsetup on your web server to enable it. If you're not familiar with what you need to do on your web server to enable\nCORS, a quick google search should give you plenty of answers.</p>\n\n<p>Assuming your server is set up though, sending a CORS request is easy:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'http://www.somedomain.com/some/awesome/url.php',\n    withCredentials: true,\n    useDefaultXhrHeader: false\n});\n</code></pre>\n\n<h2 id='ajax-section-3'>Form Uploads</h2>\n\n<p>The final thing we'll cover is uploading forms. This is also really easy:</p>\n\n<pre><code><a href=\"#!/api/Ext.Ajax-method-request\" rel=\"Ext.Ajax-method-request\" class=\"docClass\">Ext.Ajax.request</a>({\n    url: 'myUrl',\n    form: 'myFormId',\n\n    callback: function(response, successful) {\n        if (successful) {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Success', 'We got your form submission');\n        } else {\n            <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('Fail', 'Hmm, that did not work');\n        }\n    }\n});\n</code></pre>\n\n<p>This finds a &lt;form&gt; tag on the page with id=\"myFormId\", grabs its data and puts it into the request params object\njust like at the start of this guide. Then it submits it to the url you specified and calls your callbacks like normal.</p>\n"});