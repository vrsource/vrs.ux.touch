Ext.data.JsonP.events({"title":"Events","guide":"<h1>Understanding and Using Events in Sencha Touch 2</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/events-section-1'>What Are Events?</a></li>\n<li><a href='#!/guide/events-section-2'>Listening to Events</a></li>\n<li><a href='#!/guide/events-section-3'>Config-driven events</a></li>\n<li><a href='#!/guide/events-section-4'>Adding Listeners Later</a></li>\n<li><a href='#!/guide/events-section-5'>Removing Listeners</a></li>\n<li><a href='#!/guide/events-section-6'>Listener Options</a></li>\n<li><a href='#!/guide/events-section-7'>Firing Your Own Events</a></li>\n<li><a href='#!/guide/events-section-8'>Conclusions</a></li>\n</ol>\n</div>\n\n<p>The Components and classes of Sencha Touch 2 fire a broad range of events at various points in their lifecycle. Events allow your code to react to changes around it and are a key concept within Sencha Touch.</p>\n\n<h2 id='events-section-1'>What Are Events?</h2>\n\n<p>Events are fired whenever something interesting happens to one of your classes. For example, when any Component is rendered to the screen its <a href=\"#!/api/Ext.Component-event-painted\" rel=\"Ext.Component-event-painted\" class=\"docClass\">painted</a> event is fired. We can listen for that event by configuring a simple <a href=\"#!/api/Ext.mixin.Observable-cfg-listeners\" rel=\"Ext.mixin.Observable-cfg-listeners\" class=\"docClass\">listeners</a> config:</p>\n\n<pre class='inline-example '><code><a href=\"#!/api/Ext-method-create\" rel=\"Ext-method-create\" class=\"docClass\">Ext.create</a>('<a href=\"#!/api/Ext.Panel\" rel=\"Ext.Panel\" class=\"docClass\">Ext.Panel</a>', {\n    html: 'My Panel',\n    fullscreen: true,\n\n    listeners: {\n        painted: function() {\n            alert('I was painted to the screen');\n        }\n    }\n});\n</code></pre>\n\n<p>When you click the \"Live Preview\" button above you'll see the Panel rendered to the screen followed by our alert message. All of the events fired by a class are listed in its API page - for example <a href=\"#!/api/Ext.Panel\" rel=\"Ext.Panel\" class=\"docClass\">Ext.Panel</a> has 28 events at the time of writing:</p>\n\n<p><a href=\"#!/api/Ext.Panel\"><p class='screenshot'><img src='guides/events/event-list.png' alt='Hover over the Events button to quickly see which events are available'><span>Hover over the Events button to quickly see which events are available</span></p></a></p>\n\n<h2 id='events-section-2'>Listening to Events</h2>\n\n<p>The painted event itself is useful in some cases but there are other events that you're much more likely to use. For example, <a href=\"#!/api/Ext.Button\" rel=\"Ext.Button\" class=\"docClass\">Buttons</a> fire <a href=\"#!/api/Ext.Button-event-tap\" rel=\"Ext.Button-event-tap\" class=\"docClass\">tap</a> events whenever they're tapped on:</p>\n\n<pre class='inline-example '><code><a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'button',\n    centered: true,\n    text: 'My Button',\n\n    listeners: {\n        tap: function() {\n            alert(\"You tapped me\");\n        }\n    }\n});\n</code></pre>\n\n<p>We can add as many event listeners as we like. Here we're going to confound our user by calling <em>this.hide()</em> inside our tap listener to hide the Button, only to show it again a second later. When <em>this.hide()</em> is called, the Button is hidden and the <a href=\"#!/api/Ext.Button-event-hide\" rel=\"Ext.Button-event-hide\" class=\"docClass\">hide event</a> fired. The hide event in turn triggers our hide listener, which waits a second then shows the Button again:</p>\n\n<pre class='inline-example '><code><a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'button',\n    centered: true,\n    text: 'My Button',\n\n    listeners: {\n        tap: function() {\n            this.hide();\n        },\n        hide: function() {\n            //waits 1 second (1000ms) then shows the button again\n            <a href=\"#!/api/Ext-method-defer\" rel=\"Ext-method-defer\" class=\"docClass\">Ext.defer</a>(function() {\n                this.show();\n            }, 1000, this);\n        }\n    }\n});\n</code></pre>\n\n<p>Event listeners are called every time an event is fired, so you can continue hiding and showing the button for all eternity.</p>\n\n<h2 id='events-section-3'>Config-driven events</h2>\n\n<p>Most classes are reconfigurable at run time - e.g. you can change configurations like their height, width or content at any time and the Component will correctly update itself on screen. Many of these configuration changes trigger an event to be fired - for example 14 of Button's 24 events have names like <a href=\"#!/api/Ext.Button-event-widthchange\" rel=\"Ext.Button-event-widthchange\" class=\"docClass\">widthchange</a>, <a href=\"#!/api/Ext.Button-event-hiddenchange\" rel=\"Ext.Button-event-hiddenchange\" class=\"docClass\">hiddenchange</a> and <a href=\"#!/api/Ext.Button-event-centeredchange\" rel=\"Ext.Button-event-centeredchange\" class=\"docClass\">centeredchange</a>.</p>\n\n<p>This time our tap handler is just going to call this.setWidth() to set a random width on our button. Our <a href=\"#!/api/Ext.Button-event-widthchange\" rel=\"Ext.Button-event-widthchange\" class=\"docClass\">widthchange</a> listener will immediately be informed of the change, along with the new and old width values:</p>\n\n<pre class='inline-example '><code><a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'button',\n    centered: true,\n    text: 'Click me',\n\n    listeners: {\n        tap: function() {\n            var randomWidth = 100 + Math.round(Math.random() * 200);\n\n            this.setWidth(randomWidth);\n        },\n        widthchange: function(button, newWidth, oldWidth) {\n            alert('My width changed from ' + oldWidth + ' to ' + newWidth);\n        }\n    }\n});\n</code></pre>\n\n<p>Every event that ends in 'change' is fired as a result of a config option changing. Note that you listen to these events just like any other, it's just good to know the convention.</p>\n\n<h2 id='events-section-4'>Adding Listeners Later</h2>\n\n<p>Every example so far has involved passing listeners in when the class is instantiated. If we already have an instance though, we can still add listeners later using the <a href=\"#!/api/Ext.mixin.Observable-method-on\" rel=\"Ext.mixin.Observable-method-on\" class=\"docClass\">on</a> function:</p>\n\n<pre class='inline-example '><code>var myButton = <a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'button',\n    centered: true,\n    text: 'Click me'\n});\n\nmyButton.on('tap', function() {\n    alert(\"Event listener attached by .on\");\n});\n</code></pre>\n\n<p>You can add new listeners at any time this way. We can also combine these approaches, even listening to the same event more than once if we need to:</p>\n\n<pre class='inline-example '><code>var myButton = <a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'button',\n    centered: true,\n    text: 'Click me',\n\n    listeners: {\n        tap: function() {\n            alert('First tap listener');\n        }\n    }\n});\n\nmyButton.on('tap', function() {\n    alert(\"Second tap listener\");\n});\n</code></pre>\n\n<p>Both of your event listener functions are called, preserving the order they were added in.</p>\n\n<p>Finally, we can specify multiple listeners using .on, just as we could with a listener configuration. Here's our random width setting button again:</p>\n\n<pre class='inline-example '><code>var myButton = <a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'button',\n    centered: true,\n    text: 'Click me'\n});\n\nmyButton.on({\n    tap: function() {\n        var randomWidth = 100 + Math.round(Math.random() * 200);\n\n        this.setWidth(randomWidth);\n    },\n    widthchange: function(button, newWidth, oldWidth) {\n        alert('My width changed from ' + oldWidth + ' to ' + newWidth);\n    }\n});\n</code></pre>\n\n<h2 id='events-section-5'>Removing Listeners</h2>\n\n<p>Just as we can add listeners at any time, we can remove them too, this time using <a href=\"#!/api/Ext.mixin.Observable-method-un\" rel=\"Ext.mixin.Observable-method-un\" class=\"docClass\">un</a>. In order to remove a listener, we need a reference to its function. In all of the examples above we've just passed a function straight into the listeners object or .on call, this time we're going to create the function a little earlier and link it into a variable called <em>doSomething</em>.</p>\n\n<p>We'll pass our new <em>doSomething</em> function into our listeners object, which works just like before. This time however we'll add an <a href=\"#!/api/Ext-method-defer\" rel=\"Ext-method-defer\" class=\"docClass\">Ext.defer</a> function at the bottom that removes the listener again after 3 seconds. Clicking on the button in the first 3 seconds yields an alert message, after 3 seconds our listener is removed so nothing happens:</p>\n\n<pre class='inline-example '><code>var doSomething = function() {\n    alert('handler called');\n};\n\nvar myButton = <a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'button',\n    text: 'My Button',\n    centered: true,\n\n    listeners: {\n        tap: doSomething\n    }\n});\n\n<a href=\"#!/api/Ext-method-defer\" rel=\"Ext-method-defer\" class=\"docClass\">Ext.defer</a>(function() {\n    myButton.un('tap', doSomething);\n}, 3000);\n</code></pre>\n\n<p>In this example we're adding a button like before, but this time also adding a toggle button that will add and remove the tap listener as you toggle it. The listener starts off disabled, use the toggle button to enable and later disable it:</p>\n\n<pre class='inline-example '><code>var myButton = <a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'button',\n    centered: true,\n    text: 'Listener Disabled'\n});\n\nvar handler = function() {\n    alert('listener called');\n};\n\n<a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'togglefield',\n    docked: 'bottom',\n    label: 'Toggle Listener',\n\n    listeners: {\n        change: function(field, thumb, enabled) {\n            if (enabled) {\n                myButton.on('tap', handler);\n                myButton.setText('Listener Enabled');\n            } else {\n                myButton.un('tap', handler);\n                myButton.setText('Listener Disabled');\n            }\n        }\n    }\n});\n</code></pre>\n\n<h2 id='events-section-6'>Listener Options</h2>\n\n<p>There are a few additional options that we can pass into listeners.</p>\n\n<h3>Scope</h3>\n\n<p>Scope sets the value of <em>this</em> inside your handler function. By default <em>this</em> is set to the instance of the class firing the event, which is often (but not always) what you want. That's what allowed us to call <em>this.hide()</em> to hide the button in the second example near the start of this guide.</p>\n\n<p>This time we'll create a Button and a Panel, then listen to the Button's 'tap' event with our handler running in Panel's scope. To do this we need to pass in an object instead of a handler function - this object contains the function plus the scope:</p>\n\n<pre class='inline-example '><code>var myButton = <a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n    xtype: 'button',\n    centered: true,\n    text: 'Click me'\n});\n\nvar panel = <a href=\"#!/api/Ext-method-create\" rel=\"Ext-method-create\" class=\"docClass\">Ext.create</a>('<a href=\"#!/api/Ext.Panel\" rel=\"Ext.Panel\" class=\"docClass\">Ext.Panel</a>', {\n    html: 'Panel HTML'\n});\n\nmyButton.on({\n    tap: {\n        scope: panel,\n        fn: function() {\n            alert(\"Running in Panel's scope\");\n            alert(this.getHtml());\n        }\n    }\n});\n</code></pre>\n\n<p>When you run this example, the value of <em>this</em> in the tap handler is the Panel. To see this we'd set the Panel's <a href=\"#!/api/Ext.Panel-cfg-html\" rel=\"Ext.Panel-cfg-html\" class=\"docClass\">html</a> configuration to 'Panel HTML' and then alerted this.getHtml() in our handler. When we tap the button we do indeed see the Panel's html being alerted.</p>\n\n<h3>Single</h3>\n\n<p>Sometimes we only want to listen to an event one time. The event itself might fire any number of times, but we only want to listen to it once. This is simple:</p>\n\n<pre class='inline-example '><code>var myButton = <a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n   xtype: 'button',\n   centered: true,\n   text: 'Click me',\n\n   listeners: {\n       tap: {\n           single: true,\n           fn: function() {\n               alert(\"I will say this only once\");\n           }\n       }\n   }\n});\n</code></pre>\n\n<h3>Buffer</h3>\n\n<p>For events that are fired many times in short succession, we can throttle the number of times our listener is called by using the buffer configuration. In this case our button's tap listener will only be invoked once every 2 seconds, regardless of how many times you click it:</p>\n\n<pre class='inline-example '><code>var myButton = <a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n   xtype: 'button',\n   centered: true,\n   text: 'Click me',\n\n   listeners: {\n       tap: {\n           buffer: 2000,\n           fn: function() {\n               alert(\"I will say this only once every 2 seconds\");\n           }\n       }\n   }\n});\n</code></pre>\n\n<h2 id='events-section-7'>Firing Your Own Events</h2>\n\n<p>Firing your own events is really simple - you can just call <a href=\"#!/api/Ext.mixin.Observable-method-fireEvent\" rel=\"Ext.mixin.Observable-method-fireEvent\" class=\"docClass\">fireEvent</a> with any event name. In this case we'll fire an event called <em>myEvent</em> that passes two arguments - the button itself an a number between 1 and 100:</p>\n\n<pre class='inline-example '><code>var myButton = <a href=\"#!/api/Ext.Viewport-event-add\" rel=\"Ext.Viewport-event-add\" class=\"docClass\">Ext.Viewport.add</a>({\n   xtype: 'button',\n   centered: true,\n   text: \"Just wait 2 seconds\",\n\n   listeners: {\n       myEvent: function(button, points) {\n           alert('myEvent was fired! You score ' + points + ' points');\n       }\n   }\n});\n\n<a href=\"#!/api/Ext-method-defer\" rel=\"Ext-method-defer\" class=\"docClass\">Ext.defer</a>(function() {\n    var number = Math.ceil(Math.random() * 100);\n\n    myButton.fireEvent('myEvent', myButton, number);\n}, 2000);\n</code></pre>\n\n<p>Once again we used <a href=\"#!/api/Ext-method-defer\" rel=\"Ext-method-defer\" class=\"docClass\">Ext.defer</a> to delay the function that fires our custom event, this time by 2 seconds. When the event is fired, our myEvent listener picks up on it and alerts the arguments we passed in.</p>\n\n<h2 id='events-section-8'>Conclusions</h2>\n\n<p>Events are a key part of Sencha Touch 2 and keep your app informed of changes in the system. If you're new to Sencha Touch we suggest checking out these guides to get a better grounding in how everything works:</p>\n\n<ul>\n<li><a href=\"#!/guide/components\">Understanding Components</a></li>\n<li><a href=\"#!/guide/class_system\">Understanding the Class System</a></li>\n</ul>\n\n"});